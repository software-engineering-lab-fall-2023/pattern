# Pattern

- Pouya Esmaili - 98105581
- Nazanin Azarian - 98105568


# گزارش
در این آزمایش نحوه‌ی ارسال بسته کاملا شبیه به الگوری Strategy بود به همین علت از این الگو در پیاده‌سازی منطق آن استفاده شده‌است. با این کار می‌توان در هر زمان با تغییر استراتژی، نحوه محاسبه‌ی قیمت بسته در آینده را مشخص کرد. همچنین وضعیت بسته نیز مانند الگوی State بود. بنابراین منطق پیاده‌سازی شده در Main بدون نیاز به توجه به وضعیتی که در آن هستیم، فقط لازم است تابع مربوطه در بسته را صدا بزند تا وضعیت بسته به حالت بعدی رفته و پیام مورد نظر چاپ شود و همچنین به انتها رسیدن کار بسته مشخص شود.

# پرسش‌ها
## سوال ۱
الگوهای سازنده (Creational Patterns): تمرکز اصلی این الگوها بر نحوه‌ی ساخت اشیا است. برای این کار روش‌هایی را ارائه می‌دهند که بتوان یک شی با ویژگی‌های مشخص ساخت. مانند الگوی Factory و Singleton.

الگوهای ساختاری (Structural Patterns): هدف این الگوها ترکیب کلاس‌ها برای ایجاد یک ساختار بزرگ‌تر است. برای این کار تلاش می‌کنند یک ساختار غیر وابسته برای ارتباط اجزای مختلف ارائه دهند. مانند الگوی Bridge.

الگوهای رفتاری (): این الگوها نحوه‌ی تعامل بین اشیا را تعریف می‌کنند و به نوعی ارتباط بین آن‌ها را کپسوله می‌کنند. مانند الگوی Strategy.

## سوال ۲
الگوی استراتژی یک الگوی رفتاری است چون تعامل بین بسته و نحوه‌ی ارسال را مشخص می‌کند. الگوی وضعیت نیز به طور مشابه ارتباط بین بسته و وضعیت فعلی را مشخص می‌کند.

## سوال ۳
با توجه به این که فقط یک شی از این کلاس در برنامه نیاز داریم می‌توانستیم از الگوی Singleton استفاده کنیم و مقدار وزن را بعدا در آن ست کنیم. برای تحقق این الگو دیگر نیاز به ساخت شی بسته در کلاس Main نبود و کافی بود فقط instance آن را بگیریم.

## سوال ۴
اصل Single Responsibility: این اصل در این الگو به طور عادی رعایت می‌شود ولی ممکن است با پیاده‌سازی اشتباه مسئولیت بیشتری در پیاده‌سازی Singleton قرار دهیم.

اصل Open/Closed Principle: Singleton بودن یک کلاس مشکلی در رعایت این اصل ایجاد نمی‌کند و می‌توان به کدهای این کلاس توابع جدید نیز اضافه کرد.

اصل Liskov Substitution Principle: با توجه به نحوه‌ی پیاده‌سازی، امکان استفاده از کلاس Singleton به جای شی از کلاس پدر وجود دارد ولی ممکن است امکان استفاده از فرزند کلاس Singleton به جای این کلاس وجود نداشته باشد. البته با پیاده‌سازی مناسب می‌توان از این مشکل نیز جلوگیری کرد.

اصل Interface Segregation Principle: این الگو هیچ مشکلی با این اصل نداشته و می‌توان در کلاس Singleton اینترفیس‌های مورد نیاز را استفاده کرد.

اصل Dependency Inversion Principle: با توجه به نحوه‌ی دسترسی به شی از یک کلاس Singleton، وابستگی مستقیم به این کلاس به وجود آمده و امکان Dependency Inversion از بین می‌رود. البته این موضوع را نیز می‌توان با پیاده‌سازی درست برطرف کرد.